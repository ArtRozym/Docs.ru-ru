---
title: Вопросы безопасности в ASP.NET Core SignalR
author: tdykstra
description: Узнайте, как использовать проверку подлинности и авторизации в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 10/17/2018
uid: signalr/security
ms.openlocfilehash: be1dd24c40327d9a0d8f91bf75300128d3d52725
ms.sourcegitcommit: fc7eb4243188950ae1f1b52669edc007e9d0798d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2018
ms.locfileid: "51225373"
---
# <a name="security-considerations-in-aspnet-core-signalr"></a>Вопросы безопасности в ASP.NET Core SignalR

По [Andrew Stanton медсестра](https://twitter.com/anurse)

В этой статье сведения об обеспечении безопасности SignalR.

## <a name="cross-origin-resource-sharing"></a>Общий доступ к ресурсам независимо от источника

[Кросс-совместного использования ресурсов (CORS)](https://www.w3.org/TR/cors/) может использоваться для подключений SignalR независимо от источника в браузере. Если код JavaScript размещается в домене, отличном от приложения SignalR, [по промежуточного слоя CORS](xref:security/cors) необходимо включить, чтобы разрешить JavaScript для подключения к приложению SignalR. Разрешить запросы независимо от источника только из доменов, которым вы доверяете или элемента управления. Пример:

* На узле размещается на `http://www.example.com`
* SignalR приложение размещено на `http://signalr.example.com`

CORS необходимо настроить в приложении SignalR, разрешая только источник `www.example.com`.

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов независимо от источника (CORS)](xref:security/cors). SignalR **требует** следующие политики CORS:

* Разрешить определенные ожидаемые источников. Позволяя любого источника возможна, но является **не** безопасное или рекомендуемые.
* Методы HTTP `GET` и `POST` должны быть разрешены.
* Необходимо включить учетные данные, даже в том случае, если не используется проверка подлинности.

Например, следующая политика CORS позволяет клиенту браузера SignalR, размещенных на `http://example.com` для доступа к приложению SignalR, размещенных на `http://signalr.example.com`:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

> [!NOTE]
> SignalR не совместим с встроенной функции CORS в службе приложений Azure.

## <a name="websocket-origin-restriction"></a>Ограничение WebSocket Origin

::: moniker range=">= aspnetcore-2.2"

Защиты, предоставляемые CORS не применяются к WebSockets. Origin ограничение на WebSockets, чтение [WebSockets origin ограничение](xref:fundamentals/websockets#websocket-origin-restriction).

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Защиты, предоставляемые CORS не применяются к WebSockets. Браузеры иметь **не**:

* Выполнение предварительных запросов CORS.
* Использовать ограничения, указанные в `Access-Control` заголовки при составлении запросов WebSocket.

Однако браузеры отправляют `Origin` заголовка при выдаче запросов WebSocket. Приложения должны проверять эти заголовки, чтобы гарантировать, что разрешены только WebSockets, поступающие от ожидаемого источников.

В ASP.NET Core 2.1 и более поздних версиях проверка заголовков можно добиться, используя пользовательские по промежуточного слоя поместить **перед `UseSignalR`и по промежуточного слоя проверки подлинности** в `Configure`:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> `Origin` Заголовок контролируется с помощью клиента и, подобно `Referer` заголовка, можно подделать. Эти заголовки должен **не** использоваться в качестве механизма проверки подлинности.

::: moniker-end

## <a name="access-token-logging"></a>Ведение журнала для маркера доступа

При использовании WebSockets или Server-Sent события, браузер клиент отправляет маркер доступа в строке запроса. Получение маркера доступа с помощью строки запроса является обычно так безопасен, как с помощью стандарта `Authorization` заголовка. Тем не менее многие веб-серверы входа URL-адрес для каждого запроса, включая строку запроса. Ведение журнала URL-адреса могут вносить в журнал маркер доступа. Рекомендуется задать параметры ведения журнала сервера для предотвращения маркеры доступа ведения журнала в Интернете.

## <a name="exceptions"></a>Исключения

Сообщения об исключениях, как правило, являются конфиденциальных данных, которые не следует раскрывать для клиента. По умолчанию SignalR не отправляет сведения о исключения, вызванного метода концентратора клиенту. Вместо этого клиент получает универсальное сообщение, указывающее, что произошла ошибка. Доставка сообщений исключения клиенту может быть заменено (например в среде разработки или тестирования) [ `EnableDetailedErrors` ](xref:signalr/configuration#configure-server-options). Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalR использует буферы подключения для управления входящих и исходящих сообщений. По умолчанию SignalR ограничивает эти буферы, до 32 КБ. Наибольшее сообщение, которое клиент или сервер может отправить составляет 32 КБ. Максимальная память, занятая подключение для сообщений составляет 32 КБ. Если сообщения всегда меньше 32 КБ, можно уменьшить предел, который:

* Запрещает клиента отправлять сообщения большего размера.
* Сервер никогда не потребуется выделить большие буферы для приема сообщений.

Если сообщения превышает 32 КБ, можно увеличить предел. Увеличение этого значения означает, что:

* Клиент может вызвать сервер должен выделить большие буферы памяти.
* Распределение Server больших буферов может уменьшить количество одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений, как можно настроить на [ `HttpConnectionDispatcherOptions` ](xref:signalr/configuration#configure-server-options) объект, настроенный в `MapHub`:

* `ApplicationMaxBufferSize` Представляет максимальное число байтов от клиента, буферы сервера. Если клиент пытается отправить сообщение, размер которых превышает этот предел, соединение может быть закрыт.
* `TransportMaxBufferSize` Представляет максимальное число байтов, которые сервер может отправлять. Если сервер пытается отправить сообщение (включая возвращаемые значения методов концентратора), размер которых превышает этот предел, будет вызвано исключение.

Если установленное `0` отключает ограничение. Удаление ограничения позволяет клиенту отправлять сообщения из любого размера. Вредоносные клиенты при отправке больших сообщений может привести к памяти для выделения. Использование памяти может значительно снизить количество одновременных подключений.
