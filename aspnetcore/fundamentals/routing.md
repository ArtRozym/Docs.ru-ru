---
title: Маршрутизация в ASP.NET Core
author: ardalis
description: Узнайте, как функции маршрутизации ASP.NET Core обеспечивают сопоставление входящего запроса с обработчиком маршрутов.
ms.author: riande
ms.custom: mvc
ms.date: 10/01/2018
uid: fundamentals/routing
ms.openlocfilehash: 06059d720bd4444b1ec12e42d466ee54d1658203
ms.sourcegitcommit: 375e9a67f5e1f7b0faaa056b4b46294cc70f55b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2018
ms.locfileid: "50207760"
---
# <a name="routing-in-aspnet-core"></a>Маршрутизация в ASP.NET Core

Авторы: [Райан Новак](https://github.com/rynowak) (Ryan Nowak), [Стив Смит](https://ardalis.com/) (Steve Smith) и [Рик Андерсон](https://twitter.com/RickAndMSFT) (Rick Anderson)

Функция маршрутизации обеспечивает сопоставление входящего запроса с обработчиком маршрутов. Маршруты определяются в приложении и настраиваются при его запуске. Маршрут может также извлекать значения из содержащегося в запросе URL-адреса, которые затем используются для обработки запроса. С помощью сведений о маршрутах из приложения функция маршрутизации также может формировать URL-адреса, сопоставленные с обработчиками маршрутов. Таким образом, маршрутизация позволяет находить обработчик маршрутов по URL-адресу или URL-адрес, соответствующий определенному обработчику маршрутов, на основе сведений об обработчике.

> [!IMPORTANT]
> В этом документе рассматривается низкоуровневая маршрутизация ASP.NET Core. Сведения о маршрутизации ASP.NET Core MVC см. в разделе <xref:mvc/controllers/routing>.

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/routing/samples) ([как скачивать](xref:index#how-to-download-a-sample))

## <a name="routing-basics"></a>Основы маршрутизации

Маршрутизация использует *маршруты* (реализации интерфейса <xref:Microsoft.AspNetCore.Routing.IRouter>) в следующих целях:

* для сопоставления входящих запросов с *обработчиками маршрутов*;
* для создания URL-адресов, используемых в ответах.

Как правило, приложение имеет одну коллекцию маршрутов. При поступлении запроса коллекция маршрутов обрабатывается по порядку. Входящий запрос ищет маршрут, соответствующий URL-адресу запроса, вызывая метод <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> для каждого маршрута, имеющегося в коллекции маршрутов. В свою очередь, ответ может использовать маршрутизацию для формирования URL-адресов (например, для перенаправления или ссылок) на основе сведений о маршрутах, что позволяет избежать жесткого задания URL-адресов и упрощает поддержку.

Функция маршрутизации подключается к конвейеру [ПО промежуточного слоя](xref:fundamentals/middleware/index) с помощью класса <xref:Microsoft.AspNetCore.Builder.RouterMiddleware>. [ASP.NET Core MVC](xref:mvc/overview) добавляет функцию маршрутизации в конвейер ПО промежуточного слоя в процессе настройки. Сведения об использовании маршрутизации в виде отдельного компонента см. в руководстве по [использованию ПО промежуточного слоя маршрутизации](#use-routing-middleware).

### <a name="url-matching"></a>Соответствие URL-адресов

Соответствие URL-адресов — это процесс, с помощью которого функция маршрутизации отправляет входящий запрос в *обработчик*. Этот процесс основывается на данных в пути URL-адреса, но может быть расширен для учета любых данных в запросе. Возможность отправки запросов в отдельные обработчики имеет первостепенное значение для масштабирования размера и сложности приложения.

Входящие запросы поступают в объект `RouterMiddleware`, который вызывает метод <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> для каждого маршрута по порядку. Экземпляр <xref:Microsoft.AspNetCore.Routing.IRouter> решает, следует ли *обрабатывать* запрос, присваивая свойству [RouteContext.Handler](xref:Microsoft.AspNetCore.Routing.RouteContext.Handler*) значение <xref:Microsoft.AspNetCore.Http.RequestDelegate>, отличное от NULL. Если маршрут задает обработчик для запроса, обработка маршрутов останавливается и обработчик вызывается для обработки запроса. Если были проверены все маршруты, но обработчик для запроса не найден, ПО промежуточного слоя вызывает *next*, и вызывается следующее ПО промежуточного слоя в конвейере запросов.

Основные входные данные метода `RouteAsync` — это объект [RouteContext.HttpContext](xref:Microsoft.AspNetCore.Routing.RouteContext.HttpContext*), связанный с текущим запросом. `RouteContext.Handler` и [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData*) являются выходными значениями, заданными после нахождения соответствующего маршрута.

При нахождении соответствия во время выполнения метода `RouteAsync` свойствам объекта `RouteContext.RouteData` также присваиваются значения с учетом уже выполненной на данный момент обработки. Если маршрут соответствует запросу, объект `RouteContext.RouteData` содержит важные сведения о *результате*.

[RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values*) — это словарь *значений маршрута*, полученных из маршрута. Как правило, эти значения определяются путем разбивки URL-адреса на сегменты и могут использоваться для принятия входных данных пользователя или принятия дальнейших решений об отправке в приложении.

[RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*) — это контейнер свойств с дополнительными данными, связанными с соответствующим маршрутом. Свойства `DataTokens` обеспечивают связывание данных состояния с каждым маршрутом, что позволяет приложению в дальнейшем принимать решения в зависимости от соответствующего маршрута. Эти значения определяются разработчиком и никоим образом **не** влияют на поведение маршрутизации. Кроме того, значения, спрятанные в `RouteData.DataTokens`, могут быть любого типа в отличие от `RouteData.Values`, которые должны легко преобразовываться в строки и из строк.

[RouteData.Routers](xref:Microsoft.AspNetCore.Routing.RouteData.Routers*) — это список маршрутов, которые участвовали в успешном сопоставлении с запросом. Маршруты могут быть вложены друг в друга. Свойство `Routers` отражает путь по логическому дереву маршрутов, который привел к совпадению. Как правило, первый элемент в свойстве `Routers` — это коллекция маршрутов, используемая для формирования URL-адресов. Последний элемент в свойстве `Routers` — это соответствующий обработчик маршрутов.

### <a name="url-generation"></a>Формирование URL-адреса

Формирование URL-адреса — это процесс создания пути URL-адреса функцией маршрутизации на основе набора значений маршрута. Он обеспечивает логическое разделение обработчиков и URL-адресов, по которым к ним осуществляется доступ.

Формирование URL-адреса — это итеративный процесс, который начинается с того, что пользовательский код или код платформы вызывает метод <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> коллекции маршрутов. Затем по очереди вызывается метод `GetVirtualPath` каждого *маршрута*, пока не будет возвращен объект <xref:Microsoft.AspNetCore.Routing.VirtualPathData>, отличный от NULL.

Основные входные параметры метода `GetVirtualPath`:

* [VirtualPathContext.HttpContext](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.HttpContext*)
* [VirtualPathContext.Values](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values*)
* [VirtualPathContext.AmbientValues](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues*)

Для определения возможности создания URL-адреса и включаемых значений в первую очередь используются значения, передаваемые в свойствах `Values` и `AmbientValues`. `AmbientValues` — это набор значений маршрута, полученных в результате сопоставления текущего запроса с системой маршрутизации. В свою очередь, `Values` — это значения, определяющие способ создания нужного URL-адреса для текущей операции. `HttpContext` предоставляется в том случае, если маршруту необходимо получить службы или дополнительные данные, связанные с текущим контекстом.

> [!TIP]
> Можно рассматривать [VirtualPathContext.Values](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values*) как набор переопределений для [VirtualPathContext.AmbientValues](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues*). При формировании URL-адреса производится попытка повторного использования значений маршрута из текущего запроса, что упрощает создание URL-адресов для ссылок с помощью того же маршрута или значений маршрута.

Выходные данные метода `GetVirtualPath` содержатся в объекте `VirtualPathData`. Объект `VirtualPathData` аналогичен `RouteData`. `VirtualPathData` содержит `VirtualPath` для выходного URL-адреса, а также ряд дополнительных свойств, которые должны быть заданы маршрутом.

Свойство [VirtualPathData.VirtualPath](xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath*) содержит *виртуальный путь*, создаваемый маршрутом. В зависимости от ситуации путь может требовать дальнейшей обработки. Чтобы представить созданный URL-адрес в формате HTML, добавьте в его начало базовый путь приложения.

[VirtualPathData.Router](xref:Microsoft.AspNetCore.Routing.VirtualPathData.Router*) — это ссылка на маршрут, который успешно создал URL-адрес.

Свойства [VirtualPathData.DataTokens](xref:Microsoft.AspNetCore.Routing.VirtualPathData.DataTokens*) представляют собой словарь дополнительных данных, связанных с маршрутом, который создал URL-адрес. Это эквивалент объекта [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*).

### <a name="creating-routes"></a>Создание маршрутов

Маршрутизация предоставляет класс <xref:Microsoft.AspNetCore.Routing.Route> в качестве стандартной реализации <xref:Microsoft.AspNetCore.Routing.IRouter>. Класс `Route` использует синтаксис *шаблона маршрута* для определения шаблонов, которые будут сопоставляться с путем URL-адреса при вызове метода <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*>. При вызове метода `GetVirtualPath` объект `Route` будет использовать тот же шаблон маршрута для создания URL-адреса.

Большинство приложений создают маршруты, вызывая метод <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> или один из аналогичных методов расширения, определенных в интерфейсе <xref:Microsoft.AspNetCore.Routing.IRouteBuilder>. Все эти методы создают экземпляр класса <xref:Microsoft.AspNetCore.Routing.Route> и добавляют его в коллекцию маршрутов.

`MapRoute` не принимает параметр обработчика маршрутов. `MapRoute` только добавляет маршруты, которые обрабатываются <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>. Так как обработчик по умолчанию — это интерфейс `IRouter`, он может решить не обрабатывать запрос. Например, ASP.NET Core MVC обычно настраивается в качестве обработчика по умолчанию, который обрабатывает только те запросы, которые соответствуют доступным контроллеру и действию. Дополнительные сведения о маршрутизации в MVC см. в разделе <xref:mvc/controllers/routing>.

В следующем коде приводится пример вызова `MapRoute`, используемого в типичном определении маршрута ASP.NET Core MVC:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

Этот шаблон соответствует такому пути URL-адреса, как `/Products/Details/17`, и извлекает значения маршрута `{ controller = Products, action = Details, id = 17 }`. Значения маршрута определяются с помощью разделения пути URL-адреса на сегменты и сопоставления каждого сегмента с именем *параметра маршрута* в шаблоне маршрута. Параметры маршрута являются именованными. Они определяются путем заключения имени параметра в фигурные скобки `{ ... }`.

Приведенный выше шаблон может также соответствовать пути URL-адреса `/`. В этом случае он предоставляет значения `{ controller = Home, action = Index }`. Связано это с тем, что параметры маршрута `{controller}` и `{action}` имеют значения по умолчанию, а параметр маршрута `id` является необязательным. Значение по умолчанию для параметра маршрута определяется с помощью знака равенства `=`, за которым следует значение, после имени параметра. Вопросительный знак `?` после имени параметра маршрута определяет параметр как необязательный. Параметры маршрута со значением по умолчанию *всегда* предоставляют значения маршрута при совпадении маршрута. Необязательные параметры не предоставляют значение маршрута, если нет соответствующего сегмента пути URL-адреса.

Подробное описание функций и синтаксиса шаблона маршрута см. в разделе [Справочник по шаблону маршрута](#route-template-reference).

В этом примере применяется *ограничение маршрута*:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
```

Этот шаблон соответствует такому пути URL-адреса, как `/Products/Details/17`, но не `/Products/Details/Apples`. В определении параметра маршрута `{id:int}` определяется [ограничение маршрута](#route-constraint-reference) для параметра маршрута `id`. Ограничения маршрута реализуют интерфейс <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> и проверяют значения маршрута. В этом примере значение маршрута `id` должно иметь возможность преобразования в целое число. Более подробное описание ограничений маршрутов, предоставляемых платформой, см. в разделе [Справочник по ограничениям маршрутов](#route-constraint-reference).

Дополнительные перегрузки `MapRoute` принимают значения для параметров `constraints`, `dataTokens` и `defaults`. Эти дополнительные параметры метода `MapRoute` определены как имеющие тип `object`. Типичное применение этих параметров состоит в передаче анонимно типизированного объекта, причем имена свойств анонимного типа соответствуют именам параметров маршрута.

В двух следующих примерах создаются эквивалентные маршруты:

```csharp
routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
```

> [!TIP]
> Встроенный синтаксис определения ограничений и значений по умолчанию может быть удобнее для простых маршрутов. Однако некоторые возможности, например токены данных, не поддерживаются встроенным синтаксисом.

В следующем примере показано еще несколько сценариев:

```csharp
routes.MapRoute(
    name: "blog",
    template: "Blog/{*article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
```

Этот шаблон соответствует такому пути URL-адреса, как `/Blog/All-About-Routing/Introduction`, и извлекает значения `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }`. Значения маршрута по умолчанию для `controller` и `action` предоставляются маршрутом несмотря на то, что в шаблоне нет соответствующих параметров маршрута. Значения по умолчанию можно указать в шаблоне маршрута. Параметр маршрута `article` определяется как *универсальный* с помощью звездочки `*` перед его именем. Универсальные параметры маршрута служат для фиксации оставшейся части пути URL-адреса, а также могут соответствовать пустой строке.

В этом примере добавляются ограничения маршрута и токены данных:

```csharp
routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
```

Этот шаблон будет соответствовать такому пути URL-адреса, как `/en-US/Products/5`, и будет извлекать значения `{ controller = Products, action = Details, id = 5 }` и токены данных `{ locale = en-US }`.

![Токены в окне "Локальные"](routing/_static/tokens.png)

### <a name="url-generation"></a>Формирование URL-адреса

Класс `Route` может также формировать URL-адрес, объединяя набор значений маршрута с шаблоном маршрута. С логической точки зрения, этот процесс обратен сопоставлению пути URL-адреса.

> [!TIP]
> Чтобы лучше понять процесс формирования URL-адреса, представьте себе, какой URL-адрес нужно создать, а затем подумайте, как шаблон маршрута будет сопоставляться с этим URL-адресом. Какие значения будут получены? Примерно так производится формирование URL-адреса в классе `Route`.

В этом примере используется базовый маршрут в стиле ASP.NET Core MVC:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

При значениях маршрута `{ controller = Products, action = List }` этот маршрут создает URL-адрес `/Products/List`. Значения маршрута заменяются на соответствующие параметры маршрута для образования пути URL-адреса. Так как `id` — это необязательный параметр маршрута, отсутствие у него значения не представляет проблемы.

При значениях маршрута `{ controller = Home, action = Index }` этот маршрут создает URL-адрес `/`. Предоставленные значения маршрута соответствуют значениям по умолчанию, поэтому соответствующие им сегменты можно спокойно опустить. Оба созданных URL-адреса будут совершать круговой путь с таким же определением маршрута и предоставлять те же значения маршрута, которые использовались для формирования URL-адреса.

> [!TIP]
> Приложение, использующее платформу ASP.NET Core MVC, должно создавать URL-адреса с помощью объекта <xref:Microsoft.AspNetCore.Mvc.Routing.UrlHelper>, а не вызывать маршрутизацию напрямую.

Дополнительные сведения о формировании URL-адресов см. в [справочнике по формированию URL-адрес](#url-generation-reference).

## <a name="use-routing-middleware"></a>Использование ПО промежуточного слоя маршрутизации

::: moniker range=">= aspnetcore-2.1"

Ссылка на [метапакет Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) в файле проекта приложения.

::: moniker-end

::: moniker range="= aspnetcore-2.0"

Ссылка на [метапакет Microsoft.AspNetCore.All](xref:fundamentals/metapackage) в файле проекта приложения.

::: moniker-end

::: moniker range="< aspnetcore-2.0"

Ссылка на [метапакет Microsoft.AspNetCore.Routing](https://www.nuget.org/packages/Microsoft.AspNetCore.Routing/) в файле проекта приложения.

::: moniker-end

Добавьте маршрутизацию в контейнер службы в файле `Startup.ConfigureServices`:

::: moniker range=">= aspnetcore-2.0"

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_ConfigureServices&highlight=3)]

::: moniker-end

::: moniker range="< aspnetcore-2.0"

[!code-csharp[](routing/samples/1.x/RoutingSample/Startup.cs?name=snippet_ConfigureServices&highlight=3)]

::: moniker-end

Маршруты должны настраиваться в методе `Startup.Configure`. В приведенном примере приложения используются следующие интерфейсы API:

* `RouteBuilder`
* `Build`
* `MapGet` &ndash; — соответствует только HTTP-запросам GET.
* `UseRouter`

::: moniker range=">= aspnetcore-2.0"

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_RouteHandler)]

::: moniker-end

::: moniker range="< aspnetcore-2.0"

[!code-csharp[](routing/samples/1.x/RoutingSample/Startup.cs?name=snippet_RouteHandler)]

::: moniker-end

В таблице ниже приведены ответы с данными универсальными кодами ресурсов (URI).

| URI                  | Ответ                                          |
| -------------------- | ------------------------------------------------- |
| /package/create/3    | Hello! Значения маршрута: [operation, create], [id, 3] |
| /package/track/-3    | Hello! Значения маршрута: [operation, track], [id, -3] |
| /package/track/-3/   | Hello! Значения маршрута: [operation, track], [id, -3] |
| /package/track/      | &lt;Неудачно, нет совпадения&gt;                    |
| GET /hello/Joe       | Hi, Joe!                                          |
| POST /hello/Joe      | &lt;Неудачно, совпадение только с HTTP GET&gt;       |
| GET /hello/Joe/Smith | &lt;Неудачно, нет совпадения&gt;                    |

Если вы настраиваете один маршрут, вызовите <xref:Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter*>, передав экземпляр `IRouter`. Использовать <xref:Microsoft.AspNetCore.Routing.RouteBuilder> не нужно.

Платформа предоставляет наборов методов расширения для создания маршрутов, включая следующие:

* `MapRoute`
* `MapGet`
* `MapPost`
* `MapPut`
* `MapDelete`
* `MapVerb`

Некоторые из этих методов, например `MapGet`, требуют предоставления `RequestDelegate`. `RequestDelegate` используется в качестве *обработчика маршрутов* при совпадении маршрута. Другие методы из этого семейства позволяют настраивать конвейер ПО промежуточного слоя, который будет использоваться в качестве обработчика маршрутов. Если метод *Map* не принимает обработчик, например `MapRoute`, он будет использовать объект <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>.

Методы `Map[Verb]` используют ограничения, чтобы ограничить маршрут к HTTP-команде в имени метода. Например, см. класс <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> и тип <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>.

## <a name="route-template-reference"></a>Справочник по шаблону маршрута

Токены в фигурных скобках (`{ ... }`) определяют *параметры маршрута*, которые будут привязаны при совпадении маршрута. В сегменте маршрута можно определить несколько параметров маршрута, но они должны разделяться литеральным значением. Например, `{controller=Home}{action=Index}` будет недопустимым маршрутом, так как между `{controller}` и `{action}` нет литерального значения. Эти параметры маршрута должны иметь имена, и для них могут быть определены дополнительные атрибуты.

Весь текст, кроме параметров маршрута (например, `{id}`) и разделителя пути `/`, должен соответствовать тексту в URL-адресе. Сопоставление текста производится без учета регистра на основе декодированного представления путь URL-адреса. Для сопоставления с литеральным разделителем параметров маршрута `{` или `}` его следует экранировать путем повтора символа (`{{` или `}}`).

Шаблоны URL-адресов, которые пытаются получить имя файла с необязательным расширением, имеют свои особенности. Например, рассмотрим шаблон `files/{filename}.{ext?}`. Когда `filename` и `ext` существуют, заполняются оба значения. Если в URL-адресе есть только `filename`, маршрут совпадает, так как точка в конце `.` является необязательной. Следующие URL-адреса соответствуют этому маршруту:

* `/files/myFile.txt`
* `/files/myFile`

Вы можете использовать символ `*` в качестве префикса параметра маршрута для привязки к остальной части универсального кода ресурса (URI). Такой параметр называется *универсальным*. Например, `blog/{*slug}` соответствует любому универсальному коду ресурса (URI), начинающемуся с сегмента `/blog`, за которым следует любое значение (присваиваемое в качестве значения маршрута `slug`). Универсальные параметры также могут соответствовать пустой строке.

::: moniker range=">= aspnetcore-2.2"

Универсальный параметр экранирует соответствующие символы, если маршрут использует для формирования URL-адрес, включая символы разделителей пути (`/`). Например, маршрут `foo/{*path}` со значениями маршрутов `{ path = "my/path" }` формирует `foo/my%2Fpath`. Обратите внимание на экранированный знак косой черты. В качестве символов разделителя кругового пути используйте префикс параметра маршрута `**`. Маршрут `foo/{**path}` с `{ path = "my/path" }` формирует `foo/my/path`.

::: moniker-end

Параметры маршрута могут иметь *значения по умолчанию*. Они указываются после имени параметра и знака равенства (`=`). Например, `{controller=Home}` определяет `Home` в качестве значения по умолчанию для `controller`. Значение по умолчанию используется, если для параметра нет значения в URL-адресе. Помимо значений по умолчанию, параметры маршрута могут быть необязательными (для этого необходимо добавить вопросительный знак (`?`) в конец имени параметра, например `id?`). Различие между необязательными параметрами и параметрами маршрута по умолчанию в том, что вторые всегда имеют значения; необязательный параметр имеет значение, только если оно предоставлено URL-адресом запроса.

::: moniker range=">= aspnetcore-2.2"

Параметры маршрута могут иметь ограничения, которые должны соответствовать значению маршрута из URL-адреса. Добавив двоеточие (`:`) и имя ограничения после имени параметра маршрута, можно указать *встроенные ограничения* для параметра маршрута. Если для ограничения требуются аргументы, они указываются в скобках `( )` после имени ограничения. Чтобы указать несколько встроенных ограничений, добавьте еще одно двоеточие (`:`) и имя ограничения. Имя и аргументы ограничения передаются в службу <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> для создания экземпляра интерфейса <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>, который будет использоваться при обработке URL-адреса. Если конструктору ограничения требуются службы, они разрешаются из служб приложений внедрения зависимостей. Например, в шаблоне маршрута `blog/{article:minlength(10)}` определяется ограничение `minlength` с аргументом `10`. Более подробное описание ограничений маршрутов и список ограничений, предоставляемых платформой, см. в разделе [Справочник по ограничениям маршрутов](#route-constraint-reference).

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Параметры маршрута могут иметь ограничения, которые должны соответствовать значению маршрута из URL-адреса. Добавив двоеточие (`:`) и имя ограничения после имени параметра маршрута, можно указать *встроенные ограничения* для параметра маршрута. Если для ограничения требуются аргументы, они указываются в скобках `( )` после имени ограничения. Чтобы указать несколько встроенных ограничений, добавьте еще одно двоеточие (`:`) и имя ограничения. Имя и аргументы ограничения передаются в службу <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> для создания экземпляра интерфейса <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>, который будет использоваться при обработке URL-адреса. Например, в шаблоне маршрута `blog/{article:minlength(10)}` определяется ограничение `minlength` с аргументом `10`. Более подробное описание ограничений маршрутов и список ограничений, предоставляемых платформой, см. в разделе [Справочник по ограничениям маршрутов](#route-constraint-reference).

::: moniker-end

::: moniker range=">= aspnetcore-2.2"

Параметры маршрута также могут иметь преобразователи параметров, которые преобразуют значение параметра при создании ссылок и сопоставлении действий и страниц с URI. Как и ограничения, преобразователи параметров можно включать в параметр маршрута, добавив двоеточие (`:`) и имя преобразователя после имени параметра маршрута. Например, шаблон маршрута `blog/{article:slugify}` задает преобразователь `slugify`.

::: moniker-end

В приведенной ниже таблице показаны некоторые шаблоны маршрутов и их поведение.

| Шаблон маршрута                         | Пример соответствующего URL-адреса  | Примечания                                                                  |
| -------------------------------------- | --------------------- | ---------------------------------------------------------------------- |
| hello                                  | /hello                | Соответствует только одному пути `/hello`                                  |
| {Page=Home}                            | /                     | Соответствует и задает для параметра `Page` значение `Home`                                      |
| {Page=Home}                            | /Contact              | Соответствует и задает для параметра `Page` значение `Contact`                                   |
| {controller}/{action}/{id?}            | /Products/List        | Сопоставляется с контроллером `Products` и действием `List`                       |
| {controller}/{action}/{id?}            | /Products/Details/123 |  Сопоставляется с контроллером `Products` и действием `Details`.  `id` присваивается значение 123 |
| {controller=Home}/{action=Index}/{id?} | /                     |  Сопоставляется с контроллером `Home` и методом `Index`; `id` пропускается.       |

Использование шаблона — это, как правило, самый простой подход к маршрутизации. Ограничения и значения по умолчанию также могут указываться вне шаблона маршрута.

> [!TIP]
> Чтобы увидеть, как встроенные реализации маршрутизации, такие как `Route`, сопоставляются с запросами, включите [ведение журнала](xref:fundamentals/logging/index).

## <a name="reserved-routing-names"></a>Зарезервированные имена маршрутизации

Следующие ключевые слова являются зарезервированными именами и не могут использоваться как имена маршрутов или параметры:

* `action`
* `area`
* `controller`
* `handler`
* `page`

## <a name="route-constraint-reference"></a>Справочник по ограничениям маршрутов

Ограничения маршрута применяются, когда объект `Route` соответствует синтаксису входящего URL-адреса и путь URL-адреса был разобран на значения маршрута. Как правило, ограничения маршрута служат для проверки значения маршрута, связанного посредством шаблона маршрута, и принятия решения касательно того, является ли значение приемлемым (да или нет). Некоторые ограничения маршрута используют данные, не относящиеся к значению маршрута, для определения возможности маршрутизации запроса. Например, <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint> может принимать или отклонять запрос в зависимости от HTTP-команды.

> [!WARNING]
> Старайтесь не использовать ограничения для **проверки входных данных**, так как в результате недопустимые входные данные будут вызывать ошибку *404 (не найдено)* вместо ошибки *400 (неверный запрос)* с соответствующим сообщением. Ограничения маршрутов следует использовать для **разрешения неоднозначности** похожих маршрутов, а не для проверки входных данных определенного маршрута.

В приведенной ниже таблице показаны некоторые ограничения маршрутов и их ожидаемое поведение.

| ограничение | Пример | Примеры совпадений | Примечания |
| ---------- | ------- | --------------- | ----- |
| `int` | `{id:int}` | `123456789`, `-123456789`  | Соответствует любому целому числу |
| `bool` | `{active:bool}` | `true`, `FALSE` | Соответствует `true` или `false` (без учета регистра) |
| `datetime` | `{dob:datetime}` | `2016-12-31`, `2016-12-31 7:32pm`  | Соответствует допустимому значению `DateTime` (для инвариантного языка и региональных параметров — см. предупреждение) |
| `decimal` | `{price:decimal}` | `49.99`, `-1,000.01` | Соответствует допустимому значению `decimal` (для инвариантного языка и региональных параметров — см. предупреждение) |
| `double` | `{weight:double}` | `1.234`, `-1,001.01e8` | Соответствует допустимому значению `double` (для инвариантного языка и региональных параметров — см. предупреждение) |
| `float` | `{weight:float}` | `1.234`, `-1,001.01e8` | Соответствует допустимому значению `float` (для инвариантного языка и региональных параметров — см. предупреждение) |
| `guid` | `{id:guid}` | `CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}` | Соответствует допустимому значению `Guid` |
| `long` | `{ticks:long}` | `123456789`, `-123456789` | Соответствует допустимому значению `long` |
| `minlength(value)` | `{username:minlength(4)}` | `Rick` | Строка должна содержать не менее 4 символов |
| `maxlength(value)` | `{filename:maxlength(8)}` | `Richard` | Строка должна содержать не более 8 символов |
| `length(length)` | `{filename:length(12)}` | `somefile.txt` | Длина строки должна составлять ровно 12 символов |
| `length(min,max)` | `{filename:length(8,16)}` | `somefile.txt` | Строка должна содержать от 8 до 16 символов |
| `min(value)` | `{age:min(18)}` | `19` | Целочисленное значение не меньше 18 |
| `max(value)` | `{age:max(120)}` | `91` | Целочисленное значение не больше 120 |
| `range(min,max)` | `{age:range(18,120)}` | `91` | Целочисленное значение от 18 до 120 |
| `alpha` | `{name:alpha}` | `Rick` | Строка должна состоять из одной или нескольких букв (`a`-`z`, без учета регистра) |
| `regex(expression)` | `{ssn:regex(^\\d{{3}}-\\d{{2}}-\\d{{4}}$)}` | `123-45-6789` | Строка должна соответствовать регулярному выражению (см. советы по определению регулярного выражения) |
| `required` | `{name:required}` | `Rick` |  Определяет обязательное наличие значения, не относящегося к параметру, во время формирования URL-адреса |

К одному параметру может применяться несколько разделенных запятой ограничений. Например, следующее ограничение ограничивает параметр целочисленным значением 1 или больше:

```csharp
[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
```

> [!WARNING]
> Ограничения маршрута, которые проверяют URL-адрес и могут быть преобразованы в тип CLR (например, `int` или `DateTime`), всегда используют инвариантные язык и региональные параметры. Эти ограничения предполагают, что URL-адрес является нелокализуемым. Предоставляемые платформой ограничения маршрутов не изменяют значения, хранящиеся в значениях маршрута. Все значения маршрута, переданные из URL-адреса, сохраняются как строки. Например, ограничение `float` пытается преобразовать значение маршрута в число с плавающей запятой, но преобразованное значение служит только для проверки возможности такого преобразования.

## <a name="regular-expressions"></a>Регулярные выражения

В платформе ASP.NET Core в конструктор регулярных выражений добавляются члены `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant`. Описание этих членов см. в разделе <xref:System.Text.RegularExpressions.RegexOptions>.

В регулярных выражениях применяются разделители и токены, аналогичные используемым функцией маршрутизации и в языке C#. Токены регулярного выражения должны быть экранированы. Чтобы использовать регулярное выражение `^\d{3}-\d{2}-\d{4}$` при маршрутизации, выражение должно иметь символы `\` в виде `\\` в исходном файле C# для экранирования escape-символов строки `\` (если не используются [буквальные строковые литералы](/dotnet/csharp/language-reference/keywords/string)). Символы `{`, `}`, `[` и `]` необходимо экранировать путем их удвоения, чтобы экранировать символы-разделители параметров маршрутизации. В приведенной ниже таблице показаны регулярные выражения и их экранированные варианты.

| Выражение            | Экранированное                        |
| --------------------- | ------------------------------ |
| `^\d{3}-\d{2}-\d{4}$` | `^\\d{{3}}-\\d{{2}}-\\d{{4}}$` |
| `^[a-z]{2}$`          | `^[[a-z]]{{2}}$`               |

Регулярные выражения, используемые при маршрутизации, часто начинаются с символа `^` (соответствие с начальной позицией строки) и заканчиваются символом `$` (соответствие с конечной позицией строки). Благодаря символам `^` и `$` регулярное выражение сопоставляется со всем значением параметра маршрута. Если символы `^` и `$` отсутствуют, регулярное выражение сопоставляется с любой подстрокой внутри строки, что обычно нежелательно. В приведенной ниже таблице представлен ряд примеров и объясняются причины соответствия или несоответствия.

| Выражение   | String    | Соответствие | Комментарий               |
| ------------ | --------- |  ---- |  -------------------- |
| `[a-z]{2}`   | hello     | Да   | Соответствие подстроки     |
| `[a-z]{2}`   | 123abc456 | Да   | Соответствие подстроки     |
| `[a-z]{2}`   | mz        | Да   | Соответствует выражению    |
| `[a-z]{2}`   | MZ        | Да   | Без учета регистра    |
| `^[a-z]{2}$` |  hello    | Нет    | См. замечания, касающиеся символов `^` и `$`, выше |
| `^[a-z]{2}$` | 123abc456 | Нет    | См. замечания, касающиеся символов `^` и `$`, выше |

Дополнительные сведения о синтаксисе регулярных выражений см. в статье [Регулярные выражения в .NET Framework](/dotnet/standard/base-types/regular-expression-language-quick-reference).

Чтобы ограничить возможные значения параметра набором известных значений, используйте регулярное выражение. Например, при использовании выражения `{action:regex(^(list|get|create)$)}` значение маршрута `action` будет соответствовать только `list`, `get` или `create`. При передаче в словарь ограничений строка `^(list|get|create)$` будет эквивалентной. Ограничения, которые передаются в словарь ограничений (то есть не являются встроенными ограничениями шаблона) и не соответствуют одному из известных ограничений, также рассматриваются как регулярные выражения.

::: moniker range=">= aspnetcore-2.2"

## <a name="parameter-transformer-reference"></a>Справочник по преобразователям параметров

Преобразователи параметров:

* Выполняются при формировании ссылки для `Route`.
* Реализуйте расширение `Microsoft.AspNetCore.Routing.IOutboundParameterTransformer`.
* Настраиваются с помощью <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>.
* Принимают значение маршрута параметра и изменяют его на новое строковое значение.
* Преобразованное значение используется в сформированной ссылке.

Например, пользовательский преобразователь параметра `slugify` в шаблоне маршрута `blog\{article:slugify}` с `Url.Action(new { article = "MyTestArticle" })` формирует значение `blog\my-test-article`.

Преобразователи параметров также используются платформами для преобразования URI, в который разрешается конечная точка. Например, ASP.NET Core MVC с помощью преобразователей параметров преобразует значение маршрута, используемое для сопоставления `area`, `controller`, `action` и `page`.

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home:slugify}/{action=Index:slugify}/{id?}");
```

С помощью предыдущего маршрута действие `SubscriptionManagementController.GetAll()` сопоставляется с URI `/subscription-management/get-all`. Преобразователь параметра не изменяет значения маршрута, используемые для формирования ссылки. `Url.Action("GetAll", "SubscriptionManagement")` дает в результате `/subscription-management/get-all`.

ASP.NET Core предоставляет соглашения об API для использования преобразователей параметров со сформированными маршрутами:

* ASP.NET Core MVC поддерживает соглашение об API `Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention`. Это соглашение применяет указанный преобразователь параметров ко всем маршрутам атрибутов в приложении. Преобразователь параметров преобразует маркеры маршрутов атрибутов по мере их замены. Дополнительные сведения см. в разделе об [использовании преобразователя параметров для настройки замены маркеров](/aspnet/core/mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement).
* Страницы Razor поддерживают соглашение об API `Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention`. Это соглашение применяет указанный преобразователь параметров ко всем автоматически обнаруженным страницам Razor. Преобразователь параметров преобразует сегменты папок и имен файлов маршрутов страниц Razor. Дополнительные сведения см. в разделе об [использовании преобразователя параметров для настройки маршрутов страниц](/aspnet/core/razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes).

::: moniker-end

## <a name="url-generation-reference"></a>Справочник по формированию URL-адресов

В приведенном ниже примере показано, как создать ссылку на маршрут с использованием словаря значений маршрута и коллекции <xref:Microsoft.AspNetCore.Routing.RouteCollection>.

::: moniker range=">= aspnetcore-2.0"

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_Dictionary)]

::: moniker-end

::: moniker range="< aspnetcore-2.0"

[!code-csharp[](routing/samples/1.x/RoutingSample/Startup.cs?name=snippet_Dictionary)]

::: moniker-end

В результате приведенного выше примера создается `VirtualPath` со значением `/package/create/123`. Словарь предоставляет значения маршрута `operation` и `id` шаблона "Отслеживание маршрута пакета", `package/{operation}/{id}`. Дополнительные сведения см. в примере кода в разделе [Использование ПО промежуточного слоя маршрутизации](#use-routing-middleware) или в [примере приложения](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/routing/samples).

Второй параметр конструктора `VirtualPathContext` — это коллекция *значений окружения*. Значения окружения упрощают разработку, ограничивая число значений, которые необходимо указывать в определенном контексте запроса. Текущие значения маршрута текущего запроса считаются значениями окружения для создания ссылки. В приложении ASP.NET MVC в действии `About` контроллера `HomeController` не нужно задавать значение маршрута контроллера, указывающее на действие `Index` &mdash; используется значение окружения `Home`.

Значения окружения, которые не соответствуют параметру, игнорируются. Они также игнорируются при переопределении явно предоставленными значениями (значения следуют в URL-адресе слева направо).

Явно предоставленные значения, которым нет соответствий, добавляются в строку запроса. В приведенной ниже таблице показан результат использования шаблона маршрута `{controller}/{action}/{id?}`.

| Значения окружения                | Явные значения                   | Результат                  |
| ----------------------------- | --------------------------------- | ----------------------- |
| controller="Home"             | action="About"                    | `/Home/About`           |
| controller="Home"             | controller="Order",action="About" | `/Order/About`          |
| controller="Home",color="Red" | action="About"                    | `/Home/About`           |
| controller="Home"             | action="About",color="Red"        | `/Home/About?color=Red` |

Если маршрут имеет значение по умолчанию, которое не соответствует параметру, и это значение предоставлено явным образом, оно должно соответствовать значению по умолчанию:

```csharp
routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
```

Для этого маршрута ссылка будет создана только в том случае, если предоставлены соответствующие значения для контроллера и действия.
