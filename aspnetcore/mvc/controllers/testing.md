---
title: Тестирование логики контроллера в ASP.NET Core
author: ardalis
description: Узнайте, как протестировать логику контроллера в ASP.NET Core с помощью Moq и xUnit.
ms.author: riande
ms.date: 10/14/2016
uid: mvc/controllers/testing
ms.openlocfilehash: d0b2a25d00187c088671be147844aa892f824c6e
ms.sourcegitcommit: 64c2ca86fff445944b155635918126165ee0f8aa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2018
ms.locfileid: "41751763"
---
# <a name="test-controller-logic-in-aspnet-core"></a>Тестирование логики контроллера в ASP.NET Core

Автор: [Стив Смит](https://ardalis.com/) (Steve Smith)

Контроллеры — это центральный элемент любого приложения ASP.NET Core MVC. По этой причине необходима уверенность в том, что они работают, как планировалось. С помощью автоматических тестов можно убедиться в этом и обнаружить ошибки до ввода контроллеров в рабочую среду. Важно избегать реализации в контроллерах лишних функций, а тесты должны быть ориентированы только на функции контроллеров.

Логике контролера следует быть минимальной и не связанной с бизнес-логикой или проблемами инфраструктуры (например, с доступом к данным). Тестировать нужно логику контроллера, а не платформу. Тестируйте *работу* контроллера на основе допустимых и недопустимых значений. Проверяйте ответы контроллера на основе результата выполняемой им бизнес-операции.

Типичные функции контроллера:

* Проверяет значение `ModelState.IsValid`.
* Возвращает ответ об ошибке, если состояние `ModelState` недопустимо.
* Возвращает бизнес-элемент из хранилища.
* Выполняет действие с бизнес-элементом.
* Сохраняет бизнес-элемент в хранилище.
* Возвращает соответствующий результат `IActionResult`.

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))

## <a name="unit-tests-of-controller-logic"></a>Модульное тестирование логики контроллера

[Модульное тестирование](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) предполагает тестирование части приложения изолированно от его инфраструктуры и зависимостей. При модульном тестировании логики контроллера тестируется только содержимое отдельного действия, но не поведение его зависимостей или сама платформа. Выполняя модульное тестирование действий контроллера, следует сосредоточиться только на его поведении. В рамках модульного тестирования контроллера не учитываются такие аспекты, как [фильтры](xref:mvc/controllers/filters), [маршрутизация](xref:fundamentals/routing) или [привязка модели](xref:mvc/models/model-binding). Благодаря нацеленности на отдельный компонент модульные тесты, как правило, проще создавать, а выполняются они быстрее. Правильно составленный набор модульных тестов можно выполнять часто без значительных затрат. Однако модульные тесты не выявляют проблемы с взаимодействием между компонентами. Для этого используется [тестирование интеграции](xref:test/integration-tests).

Если вы создаете пользовательские фильтры и маршруты, их следует подвергать модульному тестированию изолированно, но не в рамках тестирования определенного действия контроллера.

> [!TIP]
> [Создавайте и выполняйте модульные тесты с помощью Visual Studio](/visualstudio/test/unit-test-your-code).

Для демонстрации модульного тестирования рассмотрим представленный ниже контроллер. Он выводит список сеансов мозгового штурма и позволяет создавать такие сеансы с помощью запроса POST.

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

Контроллер следует [принципу явных зависимостей](http://deviq.com/explicit-dependencies-principle/), предполагающему предоставление экземпляра `IBrainstormSessionRepository` при внедрении зависимостей. Благодаря этому его достаточно легко протестировать с помощью платформы макетов объектов, например [Moq](https://www.nuget.org/packages/Moq/). В методе `HTTP GET Index` нет циклов или ветвления, и он вызывает лишь один метод. Чтобы протестировать этот метод `Index`, необходимо проверить, возвращается ли результат `ViewResult` с объектом `ViewModel` из метода `List` репозитория.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

Метод `HomeController` `HTTP POST Index` (показанный выше) должен проверять, выполняются ли следующие действия:

* Метод действия возвращает результат `ViewResult` типа "Неверный запрос" с соответствующими данными, если свойство `ModelState.IsValid` имеет значение `false`.

* Вызывается метод `Add` репозитория, и возвращается результат `RedirectToActionResult` с правильными аргументами, если свойство `ModelState.IsValid` имеет значение true.

Недопустимое состояние модели можно проверить, добавив ошибки с помощью метода `AddModelError`, как показано в первом тесте ниже.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

Первый тест проверяет, возвращается ли тот же результат `ViewResult`, что и для запроса `GET`, если состояние `ModelState` недопустимо. Обратите внимание на то, что он не пытается передать недопустимую модель. Это бы в любом случае не удалось, так как привязка модели не запущена (хотя [тест интеграции](xref:test/integration-tests) использовал бы тестовую привязку модели). В этом случае привязка модели не тестируется. Эти модульные тесты проверяют только действия, выполняемые кодом в методе действия.

Второй тест проверяет, добавляется ли новый объект `BrainstormSession` (через репозиторий) и возвращает ли метод результат `RedirectToActionResult` с ожидаемыми свойствами, если состояние `ModelState` допустимо. Макеты вызовов, которые не выполняются, обычно игнорируются, но вызов `Verifiable` в конце вызова Setup позволяет проверить его в тесте. Для этого служит вызов метода `mockRepo.Verify`, в результате которого тест будет считаться непройденным, если требуемый метод не был вызван.

> [!NOTE]
> Библиотека Moq, используемая в этом примере, позволяет легко сочетать проверяемые (строгие) макеты и непроверяемые (которые также называют нестрогими макетами или заглушками). Узнайте больше о [настройке поведения макетов с помощью Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).

Другой контроллер в приложении выводит сведения, связанные с определенным сеансом мозгового штурма. Он содержит логику для обработки недопустимых значений id:

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

Действие контроллера имеет три тестируемых случая, по одному на каждый оператор `return`:

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

Приложение предоставляет функциональные возможности в виде веб-интерфейса API (список идей, связанных с сеансом мозгового штурма, и метод для добавления новых идей в сеанс):

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

Метод `ForSession` возвращает список типов `IdeaDTO`. Старайтесь не возвращать бизнес-элементы непосредственно через вызовы API, так как они часто содержат больше данных, чем требуется клиенту API, и связывают внутреннюю модель предметной области приложения с интерфейсом API, доступным извне, чего следует избегать. Сопоставлять элементы предметной области и типы, возвращаемые по сети, можно вручную (с помощью инструкции LINQ `Select`, как показано здесь) или с помощью такой библиотеки, как [AutoMapper](https://github.com/AutoMapper/AutoMapper).

Модульные тесты для методов API `Create` и `ForSession`:

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

Как уже говорилось ранее, чтобы протестировать поведение метода в случае, если состояние `ModelState` недопустимо, следует добавить ошибку модели в контроллер в рамках теста. Не пытайтесь тестировать проверку модели или привязку модели с помощью модульных тестов — проверяйте только поведение метода действия при определенных значениях `ModelState`.

Во втором тесте предполагается, что репозиторий возвращает значение NULL, поэтому макет репозитория настроен так, чтобы возвращать значение NULL. Создавать тестовую базу данных (в памяти или где-либо еще) и запрос, возвращающий этот результат, не нужно — это можно сделать в одном операторе, как показано в примере.

Последний тест проверяет, вызывается ли метод `Update` репозитория. Как и ранее, макет вызывается с помощью метода `Verifiable`, а затем вызывается метод `Verify` макета репозитория для подтверждения выполнения проверяемого метода. Проверка того, сохранил ли метод `Update` данные, не относится к задачам модульного теста. Это можно сделать с помощью теста интеграции.

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:test/integration-tests>
